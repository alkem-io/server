// generated by copilot
import { Test, TestingModule } from '@nestjs/testing';
import { TaskService } from '@services/task';
import {
  MockConfigService,
  MockElasticsearchClientProvider,
  MockEntityManagerProvider,
  MockWinstonProvider,
} from '@test/mocks';
import { defaultMockerFactory } from '@test/utils/default.mocker.factory';
import { WINSTON_MODULE_NEST_PROVIDER } from 'nest-winston';
import { SearchIngestService } from './search.ingest.service';

describe('SearchIngestService', () => {
  let service: SearchIngestService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        SearchIngestService,
        MockElasticsearchClientProvider,
        MockWinstonProvider,
        MockEntityManagerProvider,
        MockConfigService,
      ],
    })
      .useMocker(defaultMockerFactory)
      .compile();

    service = module.get<SearchIngestService>(SearchIngestService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('ingestFromScratch', () => {
    let mockTaskService: any;
    let mockLogger: any;
    let service: SearchIngestService;

    const task = { id: 'task-id' };
    const suffix = '20250923120000';

    beforeEach(async () => {
      const module: TestingModule = await Test.createTestingModule({
        providers: [
          SearchIngestService,
          MockElasticsearchClientProvider,
          MockWinstonProvider,
          MockEntityManagerProvider,
          MockConfigService,
        ],
      })
        .useMocker(defaultMockerFactory)
        .compile();

      service = module.get<SearchIngestService>(SearchIngestService);
      mockTaskService = module.get(TaskService);
      mockLogger = module.get(WINSTON_MODULE_NEST_PROVIDER);
      jest.spyOn(service as any, 'generateSuffix').mockReturnValue(suffix);
    });
    it('should completeWithError and log error if an error is thrown', async () => {
      const error = new Error('fail!');
      jest
        .spyOn(service as any, 'ingestStepCreateIndices')
        .mockRejectedValue(error);
      const completeWithErrorSpy = jest
        .spyOn(mockTaskService, 'completeWithError')
        .mockResolvedValue(undefined);
      const logSpy = jest.spyOn(mockLogger, 'error').mockImplementation();

      await service.ingestFromScratch(task as any);

      expect(completeWithErrorSpy).toHaveBeenCalledWith(
        task.id,
        expect.stringContaining('Ingest from scratch failed: fail!')
      );
      expect(logSpy).toHaveBeenCalledWith(
        error.message,
        error.stack,
        expect.anything()
      );
    });
    it('should complete the task and log success when all steps succeed', async () => {
      // Mock all dependencies and side effects for a successful run
      jest.spyOn(mockTaskService, 'complete').mockResolvedValue(undefined);
      const logSpy = jest.spyOn(mockLogger, 'verbose').mockImplementation();

      // Mock the public method's observable effects by mocking dependencies
      // Simulate the full ingest process by mocking the dependencies used in the private steps
      jest
        .spyOn(service as any, 'ingestStepCreateIndices')
        .mockImplementation(async () => {});
      jest
        .spyOn(service as any, 'ingestStepIngestIntoIndices')
        .mockImplementation(async () => {});
      jest
        .spyOn(service as any, 'ingestStepAssignAliases')
        .mockImplementation(async () => []);

      await service.ingestFromScratch(task as any);

      expect(mockTaskService.complete).toHaveBeenCalledWith(task.id);
      expect(logSpy).toHaveBeenCalledWith(
        'Search ingest from scratch completed successfully',
        expect.anything()
      );
    });
    it('should delete old indices if aliases existed', async () => {
      jest.spyOn(mockTaskService, 'complete').mockResolvedValue(undefined);

      // Mock the steps
      jest
        .spyOn(service as any, 'ingestStepCreateIndices')
        .mockImplementation(async () => {});
      jest
        .spyOn(service as any, 'ingestStepIngestIntoIndices')
        .mockImplementation(async () => {});

      // Simulate aliases existing by returning a non-empty array
      const oldAliases = [{ index: 'old-index-1' }, { index: 'old-index-2' }];
      jest
        .spyOn(service as any, 'ingestStepAssignAliases')
        .mockResolvedValue(oldAliases);

      // Spy on the delete step
      const deleteSpy = jest
        .spyOn(service as any, 'ingestStepDeleteOldIndices')
        .mockImplementation(async () => {});

      await service.ingestFromScratch(task as any);

      // Should call delete with the old index names
      expect(deleteSpy).toHaveBeenCalledWith({ id: task.id }, [
        'old-index-1',
        'old-index-2',
      ]);
      expect(mockTaskService.complete).toHaveBeenCalledWith(task.id);
    });
  });
});
