name: PR Review Metrics

# Controls when the workflow runs
on:
  pull_request:
    types: [opened, reopened, synchronize] # Run when a PR is opened, reopened, or updated

jobs:
  pr_metrics:
    runs-on: arc-runner-set
    steps:
    # 1. Checkout the repository code
    - name: Checkout Code
      uses: actions/checkout@v4
      with:
        # Fetch depth 0 is important to get the base branch reference for diffing
        fetch-depth: 0
    # 2. Setup Python environment
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.x'
    # 3. Cache Python packages
    - name: Cache Python dependencies
      uses: actions/cache@v4
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-
    # 4. Install dependencies
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        # pip install -r requirements.txt # Uncomment if you use external packages
    # 5. Collect PR Metrics
    - name: Collect PR Metrics
      id: metrics
      run: |
        # 1. Fetch the base branch to enable accurate diff calculation
        # We check out the PR branch, now we fetch the target branch for comparison
        git fetch origin ${{ github.event.pull_request.base.ref }}

        # 2. Get the PR title
        PR_TITLE=$(jq -r '.pull_request.title' "${GITHUB_EVENT_PATH}")
        PR_DESCRIPTION=$(jq -r '.pull_request.body // ""' "${GITHUB_EVENT_PATH}")

        # 3. Use 'git diff --numstat' to get stats between the base branch and the PR head
        # Format: <lines added>\t<lines removed>\t<file name>
        DIFF_STATS=$(git diff --numstat origin/${{ github.event.pull_request.base.ref }} ${{ github.sha }})

        # Initialize counters and file list
        LOC=0
        FILES=0
        # We use a newline character (\n) as the separator for the list of files
        CHANGED_PATHS=""

        # 4. Process DIFF_STATS line by line
        while IFS=$'\t' read -r ADDED DELETED FILE; do
            # Skip if line is empty or not a stat line
            if [ -z "$FILE" ]; then
                continue
            fi

            # Ignore binary files or files with only renames
            if [[ "$ADDED" != "-" && "$DELETED" != "-" ]]; then
                # Total LOC changed = Additions + Deletions
                LOC=$((LOC + ADDED + DELETED))
                FILES=$((FILES + 1))
                # Accumulate file paths, separated by a newline
                CHANGED_PATHS="${CHANGED_PATHS}${FILE}\n"
            fi
        done <<< "$DIFF_STATS"

        echo "Calculated LOC: ${LOC}, Files: ${FILES}"

        # 5. Execute the Python script with real data
        # We pass the accumulated file paths string as a single, quoted argument
        JSON_OUTPUT=$(PR_DESCRIPTION="${PR_DESCRIPTION}" python .github/workflows/review_metrics/review_metrics.py "${PR_TITLE}" "${LOC}" "${FILES}" "${CHANGED_PATHS}")

        # Extract review_type for conditional step execution
        REVIEW_TYPE=$(echo "${JSON_OUTPUT}" | python -c "import sys, json; print(json.load(sys.stdin).get('review_type', ''))")

        # Make the outputs available to subsequent steps
        echo "metrics_json=${JSON_OUTPUT}" >> $GITHUB_OUTPUT
        echo "review_type=${REVIEW_TYPE}" >> $GITHUB_OUTPUT
    # 5b. Determine whether the review label changed
    - name: Determine Review Label State
      id: review_label_state
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const raw = process.env.metrics_json || '';
          let data;
          try { data = JSON.parse(raw); } catch (e) {
            core.setFailed('Invalid metrics JSON');
            return;
          }

          const desired = data.review_type === 'LLM_ONLY'
            ? 'review/llm-only' : 'review/human-required'

          const { owner, repo } = context.repo;
          const issue_number = context.issue.number;
          const labelsResp = await github.rest.issues.listLabelsOnIssue({
            owner,
            repo,
            issue_number,
            per_page: 100
          });

          const existing = labelsResp.data
            .map(label => label.name)
            .find(name => name === 'review/llm-only' || name === 'review/human-required') || '';

          const changed = Boolean(desired && desired !== existing);

          core.setOutput('desired_label', desired);
          core.setOutput('current_label', existing);
          core.setOutput('label_changed', changed ? 'true' : 'false');
      env:
        metrics_json: ${{ steps.metrics.outputs.metrics_json }}
    # 6. Post Metrics Comment
    - name: Post Metrics Comment
      if: steps.review_label_state.outputs.label_changed == 'true'
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const raw = process.env.metrics_json || '';
          let data;
          try { data = JSON.parse(raw); } catch (e) {
            data = { error: 'Failed to parse metrics JSON', raw };
          }
          if (data.error) {
            github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `âš ï¸ Metrics collection failed: ${data.error}`
            });
            return;
          }
          const lines = [];
          lines.push('## ðŸ“Š PR Metrics Summary');
          lines.push('**Title:** ' + data.title);
          lines.push(`**Total LOC Changed:** ${data.loc_changed}`);
          lines.push(`**Files Changed:** ${data.files_changed}`);
          lines.push(`**Proposed Review Type:** ${data.review_type}`);
          lines.push('**Rationale:**');
          const rationaleParts = (data.review_rationale || '').split(';').map(s => s.trim()).filter(s => s);
          rationaleParts.forEach(part => lines.push(`  - ${part}`));
          lines.push('');
          lines.push('### Flags');
          const flags = [];
          if (data.high_risk_keyword) flags.push('High Risk Keyword');
          if (data.critical_path_change) flags.push('Critical Path Change');
          if (data.low_risk_keyword) flags.push('Low Risk Keyword');
          if (data.high_risk_trigger) flags.push('Composite High Risk Trigger');
          if (flags.length > 0) {
            flags.forEach(f => lines.push(`- **${f}**`));
          } else {
            lines.push('_No risk flags detected_');
          }
          lines.push('');
          lines.push('### Thresholds');
          lines.push('```json');
          lines.push(JSON.stringify(data.thresholds, null, 2));
          lines.push('```');
          github.rest.issues.createComment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
            body: lines.join('\n')
          });
      env:
        metrics_json: ${{ steps.metrics.outputs.metrics_json }}
    # 7. Add Label Based on Review Type
    - name: Add Review Type Label
      if: steps.review_label_state.outputs.label_changed == 'true'
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const desired = process.env.desired_label;
          const current = process.env.current_label;
          if (!desired) {
            core.info('No desired review label computed; skipping update.');
            return;
          }

          if (current) {
            try {
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                name: current
              });
            } catch (error) {
              if (error.status !== 404) {
                throw error;
              }
            }
          }

          await github.rest.issues.addLabels({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
            labels: [desired]
          });
      env:
        desired_label: ${{ steps.review_label_state.outputs.desired_label }}
        current_label: ${{ steps.review_label_state.outputs.current_label }}
